---
title: "PRUEBA"
author: "María de los Ángeles Díaz Castro"
date: "2025-11-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(seewave)
library(tuneR)
```


```{r}
reglas_nombres <- data.frame(
  nombre = c("alvaro", "Oscar", "Iyan", "MAngeles", "aza","Flor","Beatriz","Enrique",
             "Alejandra","Alice","Aurora","Bill","Callum","HermanoFlor","Jessica","Luis","Macarena","Rafael","Tito"),
  sexo   = c("M","M",     "M",    "F",     "F", "F","F","M",
             "F","F","F","M","M","M","F","M","F","M","M"),
  origen = c("P","P","P",    "P",     "P","P","IA","IA",
             "IA","IA","IA","IA","IA","P","IA","IA","IA","IA","IA"),
  acento=c("AN","N","N","AN","N","AR","N","N",
           "N","N","N","N","N","AR","N","N","N","N","N"),
  stringsAsFactors = FALSE
)

reglas_nombres$nombre <- tolower(gsub("\\s+", "", reglas_nombres$nombre))

```

```{r}
etiquetar_por_nombre <- function(nombre_archivo, reglas) {
  
  for (i in seq_len(nrow(reglas))) {
    if (grepl(reglas$nombre[i], nombre_archivo)) {
      return(list(
        sexo = reglas$sexo[i],
        origen = reglas$origen[i],
        acento=reglas$acento[i]
      ))
    }
  }
  
  return(list(
    sexo = NA,
    origen = NA,
    acento=NA
  ))
}
```

PERIOD PITCH AZAHARA: 
```{r}
period_pitch <- function(signal, fs = NULL, fmin = 80, fmax = 300) {

  # --- Convertir Wave a vector numérico ---
  if (inherits(signal, "Wave")) {
    if (is.null(fs)) fs <- signal@samp.rate

    if (isTRUE(signal@stereo)) {
      x <- (as.numeric(signal@left) + as.numeric(signal@right)) / 2
    } else {
      x <- as.numeric(signal@left)
    }

    signal <- x
  } else {
    signal <- as.numeric(signal)
  }

  signal <- signal[is.finite(signal)]
  signal <- signal - mean(signal)

  n <- length(signal)
  if (n < 10) stop("La señal tiene muy pocas muestras.")

  # --- Lags según F0 esperado ---
  lag_min <- floor(fs / fmax)
  lag_max <- ceiling(fs / fmin)
  lag_max <- min(lag_max, n - 1)

  if (lag_min >= lag_max) stop("Señal demasiado corta para estimar pitch.")

  ac <- as.numeric(acf(signal, lag.max = lag_max, plot = FALSE)$acf)
  ac <- ac[-1]

  lag <- which.max(ac[lag_min:lag_max]) + lag_min - 1
  period <- lag / fs
  pitch <- 1 / period

  # --- Clasificación por pitch ---
  gender <- if (pitch < 170) {
    "M"
  } else if (pitch > 180) {
    "F"
  } else {
    "Indeterminado"
  }

  list(
    period = period,
    pitch = pitch,
    gender = gender,
    fs = fs,
    n = n
  )
}

```


CREACIÓN DEL DATAFRAME SUPONIENDO QUE LOS AUDIOS ESTÁN EN WAV Y AÑADIENDO LA PREDICCIÓN: 

```{r}
voces_df <- data.frame(
  señal = character(),
  sexo = character(),
  origen = character(),
  acento = character(),
  duracion = numeric(),
  zcr = numeric(),
  energia_rms = numeric(),
  pitch = numeric(),        
  PREDICCIÓN_SEXO = character(),
  stringsAsFactors = FALSE
)

# SEXO: M/F
# ACENTO: AN(andaluz)/AR(argentino)/N
# ORIGEN: P(persona)/IA

añadir_voz <- function(df, ruta_wav) {
  
  # Leer audio
  audio <- readWave(ruta_wav)
  fs <- audio@samp.rate
  señal_audio <- audio@left
  
  # Duración
  duracion <- length(señal_audio) / fs
  
  # Zero Crossing Rate
 zcr <- mean(zcr(señal_audio, f = fs,plot = F))
  
  # Energía RMS
  energia_rms <- sqrt(mean(señal_audio^2))
  
  # Etiquetas 
  nombre_archivo <- tolower(basename(ruta_wav))
  nombre_archivo <- gsub("\\s+", "", nombre_archivo)

  etiquetas <- etiquetar_por_nombre(nombre_archivo, reglas_nombres)

  sexo <- etiquetas$sexo
  origen <- etiquetas$origen
  acento<-etiquetas$acento
  
  #PERIOD PITCH:
  pitch_res <- period_pitch(audio)
  pitch <- pitch_res$pitch
  pitch_gender <- pitch_res$gender
  
  # Nueva fila
  nueva_fila <- data.frame(
    señal = basename(ruta_wav),
    sexo = sexo,
    origen=origen,
    acento = acento,
    duracion = duracion,
    zcr = zcr,
    energia_rms = energia_rms,
    period_pitch = pitch,
    PREDICCIÓN_SEXO = pitch_gender,
    stringsAsFactors = FALSE
  )
  
  df <- rbind(df, nueva_fila)
  return(df)
}


```

METER TODA LA CARPETA EN EL DATAFRAME:
```{r}
df_carpeta <- function(df, carpeta) {
  archivos <- list.files(
    path = carpeta,
    pattern = "\\.wav$",
    full.names = TRUE
  )
  
  for (ruta in archivos) {
    df <- añadir_voz(df, ruta)
  }
  
  return(df)
}


```

DF_CARPETA:
```{r}
voces_df <- df_carpeta(voces_df, "Audios_finales_conv")
voces_df$sexo==voces_df$PREDICCIÓN_SEXO
```

```{r}
table(voces_df$PREDICCIÓN_SEXO)
```

```{r}
table(voces_df$sexo)
```


REGRESIÓN LOGÍSTICA:
```{r}
voces_df$gender <- ifelse(voces_df$sexo == "F", 1, 0)
table(voces_df$gender)

voces_modif<-voces_df[-c(1,2,9)]
voces_modif$origen <- factor(voces_modif$origen)
voces_modif$acento <- factor(voces_modif$acento)

mod <- glm(gender ~ ., data = voces_modif, family = binomial(link="logit"))
summary(mod)

(mod$null.deviance - mod$deviance)/mod$null.deviance
par(mfrow = c(2,2))
plot(mod)
```

K-FOLD PORQUE NO HAY SUFICIENTES DATOS:
```{r}
library(boot) 
cost <- function(r, pi = 0) mean(abs(r - (pi > 0.5)))

# Ejecutar validación cruzada k-fold (por defecto leave-one-out)
set.seed(123)
cv_result <- cv.glm(voces_modif, mod, K = 5, cost = cost)  # k = 5 folds

# Revisar resultado
cv_result$delta

```

BUSCAR SI HAY MODELOS MEJORES:
```{r}
mod_simple <- glm(gender ~ period_pitch, data = voces_modif, family = binomial)
anova(mod_simple, mod, test = "Chisq")
```

Podemos ver que el simple es mejor que si cogemos todos los datos (era lógico). Veamos que ocurre usando k-fold:

```{r}
library(boot)

# 1. Definir la función de coste (0-1 loss para clasificación)
cost <- function(r, pi = 0) mean(abs(r - (pi > 0.5)))

# 2. Ejecutar validación cruzada para el modelo simple
set.seed(123)
cv_simple <- cv.glm(voces_modif, mod_simple, K = 5, cost = cost)

# 3. Ver los resultados
print(cv_simple$delta)
```
Podemos ver que el de todo era un 13% de error y con ese modelo un 4% de error.

ENTRENAMIENTO:
```{r}
train <- sample(nrow(voces_modif),0.7 * nrow (voces_modif))
mod_pred <- glm(gender ~ period_pitch, family = binomial ( link = logit ) , data =voces_modif[ train ,])
summary ( mod_pred)

(mod_pred$null.deviance - mod_pred$deviance)/mod_pred$null.deviance
pred <- predict(mod_pred, voces_modif[-train,], type = "response")
plot(pred, voces_modif$gender[-train], pch = 20)
cor(pred, voces_modif$gender[-train])
```

# ACENTO:

```{r}
# Instalar si no lo tienes: install.packages("nnet")
library(nnet)

# Asegúrate de que 'acento' es un factor
voces_modif$acento <- as.factor(voces_modif$acento)

# Crear el modelo para predecir ACENTO
# Usamos ZCR y Energía como sugeriste

mod_acento <- multinom(acento ~ zcr + energia_rms + duracion + period_pitch, data = voces_modif, maxit=500)

summary(mod_acento)
```

```{r}
library(ggplot2)

# Gráfico para ver cómo varía el ZCR según el acento
ggplot(voces_modif, aes(x = acento, y = zcr, fill = acento)) +
  geom_boxplot() +
  labs(title = "Distribución del ZCR por Acento", y = "Zero Crossing Rate") +
  theme_minimal()
```
```{r}
# Necesitamos la log-verosimilitud del modelo completo y del modelo nulo
logL_modelo <- logLik(mod_acento)
# Creamos un modelo nulo (solo el intercepto)
mod_nulo <- nnet::multinom(acento ~ 1, data = voces_modif)
logL_nulo <- logLik(mod_nulo)

# Fórmula de McFadden: 1 - (logL_modelo / logL_nulo)
r2_mcfadden <- as.numeric(1 - (logL_modelo / logL_nulo))
print(paste("Pseudo R2 (McFadden):", round(r2_mcfadden, 4)))
```


# CENTROIDE ESPECTRAL FUNCIÓN

```{r}
library(tuneR)

spectral_centroid <- function(w) {
  fs <- as.numeric(w@samp.rate)
  x  <- as.numeric(w@left)

  # quitar media para estabilidad
  x <- x - mean(x)

  N <- length(x)

  X <- fft(x)
  K <- floor(N / 2) + 1

  P <- Mod(X[1:K])^2 #potencia espectral
  denom <- sum(P) #denominador del centroide
  if (!is.finite(denom) || denom <= 0) return(0)

  # Evitar overflow: usar double desde el principio
  freqs <- as.numeric(0:(K - 1)) * (fs / as.numeric(N))

  sum(freqs * P) / denom
}
```

```{r}
# -------- 1) listar todos los wav de la carpeta --------
files <- list.files(
  "Audioswav_prueba",
  pattern = "\\.wav$",
  full.names = TRUE
)

# -------- 2) calcular centroides --------
centroids <- sapply(files, function(f) spectral_centroid(readWave(f)))

# -------- 3) extraer persona y toma del nombre --------
names_noext <- tools::file_path_sans_ext(basename(files))

# persona = nombre sin " a1 / a2 / a3"
person <- sub("\\s+a\\d+$", "", names_noext, ignore.case = TRUE)

# toma = a1 / a2 / a3
take <- sub("^.*\\s+(a\\d+)$", "\\1", names_noext, ignore.case = TRUE)
take[!grepl("^a\\d+$", take, ignore.case = TRUE)] <- NA

# -------- 4) data frame final --------
results <- data.frame(
  file = basename(files),
  person = person,
  take = take,
  centroid_hz = centroids,
  stringsAsFactors = FALSE
)

results
```

En la voz generada por IA el centroide esn más estable y a veces más bajo, ya que el espectro esta demasiado limpio, hay menos micro-ruido, menos irregularidades y la energía está muy bien colocada en formantes.

Sin embargo, la voz humana tiene más energía dispersa y una mayor fricación irregular, respiración y turbulencia real. 

# MODELO PARA DIFERENCIAR ENTRE IA Y NO IA

```{r}
voces_df$centroid <- sapply(voces_df$señal, function(nombre) {
  w <- readWave(file.path("Audioswav_prueba", nombre))
  spectral_centroid(w)
})
```


```{r}
aggregate(centroid ~ origen + sexo, data = voces_df, summary)

ggplot(voces_df, aes(x = origen, y = centroid, fill = origen)) +
  geom_boxplot() +
  facet_wrap(~ sexo) +
  labs(title = "Centroide espectral: Humano vs IA (por sexo)") +
  theme_minimal()
```

Dentro de los hombres no hay solapamiento, por lo que las clases se podrían separar de forma perfecta con un humbral. 

Con respecto a las mujeres si hay solapamiento, por lo que habrá alguna muestra mal clasificada. 

```{r}
best_threshold <- function(df, metric = c("accuracy", "f1")) {
  metric <- match.arg(metric)

  # nos quedamos con casos válidos
  d <- df[is.finite(df$centroid) & !is.na(df$origen), ]
  if (nrow(d) < 4) stop("Muy pocos datos para calibrar umbral.")

  # IA=1, P=0
  y <- ifelse(d$origen == "IA", 1, 0)
  x <- d$centroid

  # candidatos: valores únicos del centroide (o sus puntos medios)
  ux <- sort(unique(x))
  thr_candidates <- (ux[-1] + ux[-length(ux)]) / 2
  if (length(thr_candidates) == 0) thr_candidates <- ux

  score_thr <- function(thr) {
    pred <- ifelse(x < thr, 1, 0)

    TP <- sum(pred == 1 & y == 1)
    TN <- sum(pred == 0 & y == 0)
    FP <- sum(pred == 1 & y == 0)
    FN <- sum(pred == 0 & y == 1)

    acc <- (TP + TN) / (TP + TN + FP + FN)

    prec <- if ((TP + FP) == 0) 0 else TP / (TP + FP)
    rec  <- if ((TP + FN) == 0) 0 else TP / (TP + FN)
    f1   <- if ((prec + rec) == 0) 0 else 2 * prec * rec / (prec + rec)

    if (metric == "accuracy") acc else f1
  }

  scores <- sapply(thr_candidates, score_thr)
  thr_best <- thr_candidates[which.max(scores)]
  list(threshold = thr_best, score = max(scores))
}
```

```{r}
thr_F <- best_threshold(subset(voces_df, sexo == "F"), metric = "f1")
thr_M <- best_threshold(subset(voces_df, sexo == "M"), metric = "f1")

thr_F
thr_M
```

```{r}
voces_df$PRED_IA <- NA_character_
voces_df$PRED_IA[voces_df$sexo == "F"] <- ifelse(voces_df$centroid[voces_df$sexo == "F"] < thr_F$threshold, "IA", "P")
voces_df$PRED_IA[voces_df$sexo == "M"] <- ifelse(voces_df$centroid[voces_df$sexo == "M"] < thr_M$threshold, "IA", "P")
```

```{r}
conf <- table(Real = voces_df$origen, Pred = voces_df$PRED_IA)
conf
```

