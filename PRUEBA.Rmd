---
title: "PRUEBA"
author: "María de los Ángeles Díaz Castro"
date: "2025-11-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(seewave)
library(tuneR)
```


```{r}
reglas_nombres <- data.frame(
  nombre = c("alvaro", "Oscar", "Iyan", "MAngeles", "aza","Flor","Beatriz","Enrique",
             "Alejandra","Alice","Aurora","Bill","Callum","HermanoFlor","Jessica","Luis","Macarena","Rafael","Tito"),
  sexo   = c("M","M",     "M",    "F",     "F", "F","F","M",
             "F","F","F","M","M","M","F","M","F","M","M"),
  origen = c("P","P","P",    "P",     "P","P","IA","IA",
             "IA","IA","IA","IA","IA","P","IA","IA","IA","IA","IA"),
  acento=c("AN","N","N","AN","N","AR","N","N",
           "N","N","N","N","N","AR","N","N","N","N","N"),
  stringsAsFactors = FALSE
)

reglas_nombres$nombre <- tolower(gsub("\\s+", "", reglas_nombres$nombre))

```

```{r}
etiquetar_por_nombre <- function(nombre_archivo, reglas) {
  
  for (i in seq_len(nrow(reglas))) {
    if (grepl(reglas$nombre[i], nombre_archivo)) {
      return(list(
        sexo = reglas$sexo[i],
        origen = reglas$origen[i],
        acento=reglas$acento[i]
      ))
    }
  }
  
  return(list(
    sexo = NA,
    origen = NA,
    acento=NA
  ))
}
```

PERIOD PITCH AZAHARA: 
```{r}
period_pitch <- function(signal, fs = NULL, fmin = 80, fmax = 300) {

  # --- Convertir Wave a vector numérico ---
  if (inherits(signal, "Wave")) {
    if (is.null(fs)) fs <- signal@samp.rate

    if (isTRUE(signal@stereo)) {
      x <- (as.numeric(signal@left) + as.numeric(signal@right)) / 2
    } else {
      x <- as.numeric(signal@left)
    }

    signal <- x
  } else {
    signal <- as.numeric(signal)
  }

  signal <- signal[is.finite(signal)]
  signal <- signal - mean(signal)

  n <- length(signal)
  if (n < 10) stop("La señal tiene muy pocas muestras.")

  # --- Lags según F0 esperado ---
  lag_min <- floor(fs / fmax)
  lag_max <- ceiling(fs / fmin)
  lag_max <- min(lag_max, n - 1)

  if (lag_min >= lag_max) stop("Señal demasiado corta para estimar pitch.")

  ac <- as.numeric(acf(signal, lag.max = lag_max, plot = FALSE)$acf)
  ac <- ac[-1]

  lag <- which.max(ac[lag_min:lag_max]) + lag_min - 1
  period <- lag / fs
  pitch <- 1 / period

  # --- Clasificación por pitch ---
  gender <- if (pitch < 170) {
    "M"
  } else if (pitch > 180) {
    "F"
  } else {
    "Indeterminado"
  }

  list(
    period = period,
    pitch = pitch,
    gender = gender,
    fs = fs,
    n = n
  )
}

```


CREACIÓN DEL DATAFRAME SUPONIENDO QUE LOS AUDIOS ESTÁN EN WAV Y AÑADIENDO LA PREDICCIÓN: 

```{r}
voces_df <- data.frame(
  señal = character(),
  sexo = character(),
  origen = character(),
  acento = character(),
  duracion = numeric(),
  zcr = numeric(),
  energia_rms = numeric(),
  pitch = numeric(),        
  PREDICCIÓN_SEXO = character(),
  stringsAsFactors = FALSE
)

# SEXO: M/F
# ACENTO: AN(andaluz)/AR(argentino)/N
# ORIGEN: P(persona)/IA

añadir_voz <- function(df, ruta_wav) {
  
  # Leer audio
  audio <- readWave(ruta_wav)
  fs <- audio@samp.rate
  señal_audio <- audio@left
  
  # Duración
  duracion <- length(señal_audio) / fs
  
  # Zero Crossing Rate
 zcr <- mean(zcr(señal_audio, f = fs,plot = F))
  
  # Energía RMS
  energia_rms <- sqrt(mean(señal_audio^2))
  
  # Etiquetas 
  nombre_archivo <- tolower(basename(ruta_wav))
  nombre_archivo <- gsub("\\s+", "", nombre_archivo)

  etiquetas <- etiquetar_por_nombre(nombre_archivo, reglas_nombres)

  sexo <- etiquetas$sexo
  origen <- etiquetas$origen
  acento<-etiquetas$acento
  
  #PERIOD PITCH:
  pitch_res <- period_pitch(audio)
  pitch <- pitch_res$pitch
  pitch_gender <- pitch_res$gender
  
  # Nueva fila
  nueva_fila <- data.frame(
    señal = basename(ruta_wav),
    sexo = sexo,
    origen=origen,
    acento = acento,
    duracion = duracion,
    zcr = zcr,
    energia_rms = energia_rms,
    period_pitch = pitch,
    PREDICCIÓN_SEXO = pitch_gender,
    stringsAsFactors = FALSE
  )
  
  df <- rbind(df, nueva_fila)
  return(df)
}


```

METER TODA LA CARPETA EN EL DATAFRAME:
```{r}
df_carpeta <- function(df, carpeta) {
  archivos <- list.files(
    path = carpeta,
    pattern = "\\.wav$",
    full.names = TRUE
  )
  
  for (ruta in archivos) {
    df <- añadir_voz(df, ruta)
  }
  
  return(df)
}


```

DF_CARPETA:
```{r}
voces_df <- df_carpeta(voces_df, "Audios_finales_limp")
voces_df$sexo==voces_df$PREDICCIÓN_SEXO
```

```{r}
table(voces_df$PREDICCIÓN_SEXO)
```

```{r}
table(voces_df$sexo)
```
*ANÁLISIS EXPLORATORIO:*

```{r}
summary(voces_df[, c("duracion", "zcr", "energia_rms", "period_pitch")])
```

```{r}
table(voces_df$sexo)
```

```{r}
boxplot(period_pitch ~ sexo,
        data = voces_df,
        main = "Distribución del pitch según el sexo",
        ylab = "Pitch (Hz)",
        xlab = "Sexo")
```

```{r}
vars_num <- voces_df[, c("duracion", "zcr", "energia_rms", "period_pitch")]
round(cor(vars_num, use = "complete.obs"), 2)
```


REGRESIÓN LOGÍSTICA:
```{r}
voces_df$gender <- ifelse(voces_df$sexo == "F", 1, 0)
table(voces_df$gender)

voces_modif<-voces_df[-c(1,2,9)]
voces_modif$origen <- factor(voces_modif$origen)
voces_modif$acento <- factor(voces_modif$acento)

mod <- glm(gender ~ ., data = voces_modif, family = binomial(link="logit"))
summary(mod)

(mod$null.deviance - mod$deviance)/mod$null.deviance
par(mfrow = c(2,2))
#plot(mod)
```

K-FOLD PORQUE NO HAY SUFICIENTES DATOS:
```{r}
library(boot) 
cost <- function(r, pi = 0) mean(abs(r - (pi > 0.5)))

# Ejecutar validación cruzada k-fold (por defecto leave-one-out)
set.seed(123)
cv_result <- cv.glm(voces_modif, mod, K = 5, cost = cost)  # k = 5 folds

# Revisar resultado
cv_result$delta

```

BUSCAR SI HAY MODELOS MEJORES:
```{r}
mod_simple <- glm(gender ~ period_pitch, data = voces_modif, family = binomial)
anova(mod_simple, mod, test = "Chisq")
```

Podemos ver que el simple es mejor que si cogemos todos los datos (era lógico). Veamos que ocurre usando k-fold:

```{r}
library(boot)

# 1. Definir la función de coste (0-1 loss para clasificación)
cost <- function(r, pi = 0) mean(abs(r - (pi > 0.5)))

# 2. Ejecutar validación cruzada para el modelo simple
set.seed(123)
cv_simple <- cv.glm(voces_modif, mod_simple, K = 5, cost = cost)

# 3. Ver los resultados
print(cv_simple$delta)
```
Podemos ver que el de todo era un 13% de error y con ese modelo un 4% de error.

ENTRENAMIENTO:
```{r}
train <- sample(nrow(voces_modif),0.7 * nrow (voces_modif))
mod_pred <- glm(gender ~ period_pitch, family = binomial ( link = logit ) , data =voces_modif[ train ,])
summary ( mod_pred)

(mod_pred$null.deviance - mod_pred$deviance)/mod_pred$null.deviance
pred <- predict(mod_pred, voces_modif[-train,], type = "response")
plot(pred, voces_modif$gender[-train], pch = 20)
cor(pred, voces_modif$gender[-train])
```

# ACENTO:

```{r}
# Instalar si no lo tienes: install.packages("nnet")
library(nnet)

# Asegúrate de que 'acento' es un factor
voces_modif$acento <- as.factor(voces_modif$acento)

# Crear el modelo para predecir ACENTO
# Usamos ZCR y Energía como sugeriste

mod_acento <- multinom(acento ~ zcr + energia_rms + duracion + period_pitch, data = voces_modif, maxit=500)

summary(mod_acento)
```

```{r}
library(ggplot2)

# Gráfico para ver cómo varía el ZCR según el acento
ggplot(voces_modif, aes(x = acento, y = zcr, fill = acento)) +
  geom_boxplot() +
  labs(title = "Distribución del ZCR por Acento", y = "Zero Crossing Rate") +
  theme_minimal()
```
```{r}
# Necesitamos la log-verosimilitud del modelo completo y del modelo nulo
logL_modelo <- logLik(mod_acento)
# Creamos un modelo nulo (solo el intercepto)
mod_nulo <- nnet::multinom(acento ~ 1, data = voces_modif)
logL_nulo <- logLik(mod_nulo)

# Fórmula de McFadden: 1 - (logL_modelo / logL_nulo)
r2_mcfadden <- as.numeric(1 - (logL_modelo / logL_nulo))
print(paste("Pseudo R2 (McFadden):", round(r2_mcfadden, 4)))
```


# CENTROIDE ESPECTRAL FUNCIÓN

```{r}
library(tuneR)

spectral_centroid_12 <- function(w, n_parts = 12) {
  fs <- as.numeric(w@samp.rate)
  x  <- as.numeric(w@left)
  x  <- x - mean(x)

  N <- length(x)
  if (N < n_parts * 10 || fs <= 0) return(rep(NA_real_, n_parts))

  seg_len <- floor(N / n_parts)
  cents <- rep(NA_real_, n_parts)

  for (i in seq_len(n_parts)) {
    start <- (i - 1) * seg_len + 1
    end   <- if (i < n_parts) i * seg_len else N
    seg <- x[start:end]
    seg <- seg - mean(seg)

    L <- length(seg)
    if (L < 2) next

    X <- fft(seg)
    K <- floor(L / 2) + 1
    P <- Mod(X[1:K])^2
    denom <- sum(P)
    if (!is.finite(denom) || denom <= 0) next

    freqs <- as.numeric(0:(K - 1)) * (fs / as.numeric(L))
    cents[i] <- sum(freqs * P) / denom
  }

  cents
}
```

```{r}
# -------- 1) listar todos los wav de la carpeta --------
files <- list.files(
  "Audios_finales_limp",
  pattern = "\\.wav$",
  full.names = TRUE
)

# -------- 2) calcular los 12 centroides por archivo --------
centroid_mat <- t(sapply(files, function(f) {
  w <- readWave(f)
  spectral_centroid_12(w, n_parts = 12)
}))

colnames(centroid_mat) <- paste0("centroid_", 1:12)

# -------- 3) extraer persona y take del nombre --------
names_noext <- tools::file_path_sans_ext(basename(files))

person <- sub("\\s+af\\d+$", "", names_noext, ignore.case = TRUE)

take <- sub("^.*\\s+(af\\d+)$", "\\1", names_noext, ignore.case = TRUE)
take[!grepl("^af\\d+$", take, ignore.case = TRUE)] <- NA

# -------- 4) variables extra (variación entre centroides) --------
centroid_sd12    <- apply(centroid_mat, 1, sd, na.rm = TRUE)
centroid_range12 <- apply(centroid_mat, 1, function(v) max(v, na.rm=TRUE) - min(v, na.rm=TRUE))

# diferencias entre centroides consecutivos: c2-c1, c3-c2, ...
centroid_diff_mat <- t(apply(centroid_mat, 1, function(v) diff(v)))
centroid_diff_mean <- apply(abs(centroid_diff_mat), 1, mean, na.rm = TRUE)
centroid_diff_sd   <- apply(centroid_diff_mat, 1, sd, na.rm = TRUE)

# -------- 5) data frame final --------
results <- data.frame(
  file = basename(files),
  person = person,
  take = take,
  centroid_sd12 = centroid_sd12,
  centroid_range12 = centroid_range12,
  centroid_diff_mean = centroid_diff_mean,
  centroid_diff_sd = centroid_diff_sd,
  stringsAsFactors = FALSE
)

# añadir las 12 variables al final
results <- cbind(results, as.data.frame(centroid_mat))

results
```

En la voz generada por IA el centroide esn más estable y a veces más bajo, ya que el espectro esta demasiado limpio, hay menos micro-ruido, menos irregularidades y la energía está muy bien colocada en formantes.

Sin embargo, la voz humana tiene más energía dispersa y una mayor fricación irregular, respiración y turbulencia real. 

# MODELO PARA DIFERENCIAR ENTRE IA Y NO IA

```{r}
df_all <- merge(voces_df, results, by.x = "señal", by.y = "file", all.x = TRUE)

# variable binaria objetivo
df_all$IA_bin <- ifelse(df_all$origen == "IA", 1, 0)

# asegurar factor
df_all$sexo <- factor(df_all$sexo)
```


```{r}
library(randomForest)

rf_by_sex <- function(df, sex_value, seed=123) {
  d <- subset(df, sexo == sex_value)
  feature_cols <- c(paste0("centroid_", 1:12),
                    "centroid_sd12","centroid_range12","centroid_diff_mean","centroid_diff_sd")
  d <- d[complete.cases(d[, c("origen", feature_cols)]), ]
  d$origen <- factor(d$origen)

  set.seed(seed)
  idx <- sample(nrow(d), size = floor(0.7*nrow(d)))
  train <- d[idx, ]
  test <- d[-idx, ]

  rf <- randomForest(x=train[,feature_cols], y=train$origen)
  pred <- predict(rf, newdata=test[,feature_cols])
  conf <- table(Real=test$origen, Pred=pred)
  list(confusion=conf, model=rf)
}

rf_M <- rf_by_sex(df_all, "M")
rf_F <- rf_by_sex(df_all, "F")

rf_M$confusion
rf_F$confusion
```

